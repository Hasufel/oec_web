<html><head>
<script src="/static/js/CanvasMatrix.js" type="text/javascript"></script>

<script id="line-vs" type="x-shader/x-vertex"> 
  attribute vec3 aPos;
  attribute vec3 aColor;
  uniform mat4 mvMatrix;
  uniform mat4 prMatrix;
void main(void) {
   gl_Position = prMatrix * mvMatrix * vec4( aPos, 1.);
}
</script> 
 
<script id="line-fs" type="x-shader/x-fragment"> 
precision mediump float;
void main(void) {
   gl_FragColor = vec4(1.,0.,0.,1.);
}
</script> 

<script type="text/javascript"> 

function getShader ( gl, id ){
   var shaderScript = document.getElementById ( id );
   var str = "";
   var k = shaderScript.firstChild;
   while ( k ){
     if ( k.nodeType == 3 ) str += k.textContent;
     k = k.nextSibling;
   }
   var shader;
   if ( shaderScript.type == "x-shader/x-fragment" )
           shader = gl.createShader ( gl.FRAGMENT_SHADER );
   else if ( shaderScript.type == "x-shader/x-vertex" )
           shader = gl.createShader(gl.VERTEX_SHADER);
   else return null;
   gl.shaderSource(shader, str);
   gl.compileShader(shader);
   if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
      alert(gl.getShaderInfoLog(shader));
   return shader;
}

var gl, line_prog, 
    delay = 50, transl = -50, xOffs = yOffs = 0,  drag  = 0,  xRot = yRot = 0, zOff =  0, 
     lines = [];
var I;
var r0 = 0.02, G = 1.1774e-4;
var r03 = r0*r0*r0;
var dt = .001;
var t = 0;
var x = [], y = [], z = [], vx = [], vy = [], vz = [], ax = [], ay = [], az = [];
var m = [];
m[0] = 1/G; m[1] = 1/G; m[2] = 1/G;
var mvMatrix = new CanvasMatrix4(),
    prMatrix = new CanvasMatrix4(),
    rotMat = new CanvasMatrix4();
var mvMatLoc = [], mvMatLine, lineLoc;
var M=60, N=3, K=12;
var support=true;

function webGLStart() {
   var canvas1 = document.getElementById("canvas1");
   try { gl = canvas1.getContext("experimental-webgl");
   } catch(e) {}
   if ( !gl ) { var support=false; return support;} else { var support = true; }

   line_prog  = gl.createProgram();
   gl.attachShader(line_prog, getShader( gl, "line-vs" ));
   gl.attachShader(line_prog, getShader( gl, "line-fs" ));
   lineLoc = 0;
   gl.bindAttribLocation(line_prog, lineLoc, "aPos");
   gl.linkProgram(line_prog);


   rotMat.makeIdentity();
   prMatrix.perspective(3, 1, 1, 1000);


   mvMatLine = gl.getUniformLocation(line_prog,"mvMatrix");
   gl.useProgram(line_prog);
   gl.uniformMatrix4fv( gl.getUniformLocation(line_prog,"prMatrix"),
      false, new Float32Array(prMatrix.getAsArray()) );
   init();

  canvas1.onmousedown = function ( ev ){
     drag  = 1;
     xOffs = ev.clientX;  yOffs = ev.clientY;
  }
  canvas1.onmouseup = function ( ev ){
     drag  = 0;
     xOffs = ev.clientX;  yOffs = ev.clientY;
  }
  canvas1.onmousemove = function ( ev ){
     if ( drag == 0 ) return;
     if ( ev.shiftKey ) {
        transl *= 1 + (ev.clientY - yOffs)/100;
     } else {
        yRot = - xOffs + ev.clientX;  
	xRot = - yOffs + ev.clientY; 
     }
     xOffs = ev.clientX;  yOffs = ev.clientY;
  }

  return support;
}

function init(){
   delay = 50; transl = -50; 
   xRot = 0; yRot = 0;
   xOffs = 0; yOffs = 0;  
   zOff =  0;
   drag  = 0;  
   var as = [];
   var ac = [];
   var bs = [];
   var bc = [];
   for (var i=0; i<N; i++){
      as[i] = new Array(K);
      ac[i] = new Array(K);
      bs[i] = new Array(K);
      bc[i] = new Array(K);
   }
   as[0][ 1]= 1.097640051076110; bc[0][ 1]=-0.108957450183278;
   as[0][ 3]= 0.028090182332076; bc[0][ 3]= 0.032506096677853;
   as[0][ 5]= 0.007235718283341; bc[0][ 5]= 0.003762748006231;
   as[0][ 7]= 0.001210181377945; bc[0][ 7]= 0.001308690517932;
   as[0][ 9]= 0.000397710135507; bc[0][ 9]= 0.000289369558798;
   as[0][11]= 0.000096328571545; bc[0][11]= 0.000101643863860;

   as[1][ 1]=-0.108957450183278; bc[1][ 1]= 1.097640051076109;
   as[1][ 3]=-0.032506096677853; bc[1][ 3]=-0.028090182332075;
   as[1][ 5]= 0.003762748006231; bc[1][ 5]= 0.007235718283341;
   as[1][ 7]=-0.001308690517932; bc[1][ 7]=-0.001210181377945;
   as[1][ 9]= 0.000289369558798; bc[1][ 9]= 0.000397710135507;
   as[1][11]=-0.000101643863860; bc[1][11]=-0.000096328571545;

   as[2][ 1]=-0.988682600892831; bc[2][ 1]=-0.988682600892830;
   as[2][ 3]= 0.004415914345778; bc[2][ 3]=-0.004415914345778;
   as[2][ 5]=-0.010998466289572; bc[2][ 5]=-0.010998466289572;
   as[2][ 7]= 0.000098509139987; bc[2][ 7]=-0.000098509139987;
   as[2][ 9]=-0.000687079694304; bc[2][ 9]=-0.000687079694304;
   as[2][11]= 0.000005315292314; bc[2][11]=-0.000005315292314;

   var pathx = [];
   var pathy = [];
   var pathz = [];
   for (var i=0; i<N; i++){
      pathx[i] = new Array(M);
      pathy[i] = new Array(M);
      pathz[i] = new Array(M);
   }
   for (var i=0; i<N; i++) {
     for (var j=0; j<M; j++) {
       pathx[i][j] = 0.0;
       pathy[i][j] = 0.0;
       pathz[i][j] = 0.0;
       for (var k=1; k<K; k+=2) {
         pathx[i][j] += as[i][k]*Math.sin(k*j*2*Math.PI/M);
         pathy[i][j] += bc[i][k]*Math.cos(k*j*2*Math.PI/M);
       }
     }
   }

   lines = [];
   x[0]=  0.000000; y[0]= -0.070947; z[0] = 0; 
   x[1]= -0.000000; y[1]=  1.075903; z[1] = 0; 
   x[2]= -0.000000; y[2]= -1.004957; z[2] = 0; 
   vx[0]=  1.231869; vy[0]=  0.000000; vz[0] = 0; 
   vx[1]= -0.195090; vy[1]=  0.000000; vz[1] = 0; 
   vx[2]= -1.036779; vy[2]= -0.000000; vz[2] = 0; 

   for (var j=0; j<N; j++) {
	ax[j] = 0; ay[j] = 0; az[j] = 0; 
	for (var i=0; i<N; i++) {
	    if (i != j) {
		xdiff = x[j] - x[i];
		ydiff = y[j] - y[i];
		zdiff = z[j] - z[i];
		r = Math.sqrt(xdiff*xdiff + ydiff*ydiff + zdiff*zdiff);
		r3 = r*r*r;
		if (r3<r03) r3=r03;
		ax[j] -= G * m[i] * (x[j] - x[i])/r3;
		ay[j] -= G * m[i] * (y[j] - y[i])/r3;
		az[j] -= G * m[i] * (z[j] - z[i])/r3;
	    }
	}
   }

   for (var i = 0; i < N; i++ ){
     lines.push( pathx[i][0], pathy[i][0], pathz[i][0] + zOff);  
     lines.push( pathx[i][0], pathy[i][0], pathz[i][0] + zOff);  
     for (var j=0; j<M; j++) {
       lines.push( pathx[i][j], pathy[i][j], pathz[i][j] + zOff);
     }
     lines.push( pathx[i][0], pathy[i][0], pathz[i][0] + zOff);  
     lines.push( pathx[i][0], pathy[i][0], pathz[i][0] + zOff);  
   }
   lines.push( 0,0,zOff, 1.3,0,zOff, 0,0,zOff, 0,1.3,zOff, pathx[0][0],0,zOff, 0,0,1.3+zOff);

   gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
   gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( lines ),gl.STATIC_DRAW);
   gl.vertexAttribPointer(lineLoc, 3, gl.FLOAT, false, 0, 0);
   gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());

   gl.enableVertexAttribArray( lineLoc );

   gl.enable(gl.DEPTH_TEST);
   gl.depthFunc(gl.LEQUAL);
   gl.clearDepth(1.0);
   gl.clearColor(0, 0, 0, 1);
   z[0] += zOff;
   z[1] += zOff;
   z[2] += zOff;
   timer = setInterval(draw3d, delay);
}

function draw3d(){
   gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
   rotMat.rotate(xRot, 1,0,0);  rotMat.rotate(yRot, 0,1,0);
   yRot = 0;  xRot = 0;
   gl.useProgram(line_prog);
   mvMatrix.load( rotMat );
   mvMatrix.translate(0, 0, transl);
   gl.uniformMatrix4fv( mvMatLine, false, new Float32Array(mvMatrix.getAsArray()) );
   gl.drawArrays(gl.LINE_STRIP, 0, lines.length/3);
}
</script> 
</head>

<body onload="webGLStart();"> 

<canvas id="canvas1" width="500" height="500"></canvas> 

</body></html>


