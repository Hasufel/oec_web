<html><head>
<script src="/static/js/CanvasMatrix.js" type="text/javascript"></script>

<script id="line-vs" type="x-shader/x-vertex"> 
  attribute vec3 aPos;
  attribute vec3 aColor;
  uniform mat4 mvMatrix;
  uniform mat4 prMatrix;
void main(void) {
   gl_Position = prMatrix * mvMatrix * vec4( aPos, 1.);
}
</script> 
 
<script id="line-fs" type="x-shader/x-fragment"> 
precision mediump float;
void main(void) {
   gl_FragColor = vec4(1.,0.,0.,1.);
}
</script> 

<script type="text/javascript"> 

function getShader ( gl, id ){
   var shaderScript = document.getElementById ( id );
   var str = "";
   var k = shaderScript.firstChild;
   while ( k ){
     if ( k.nodeType == 3 ) str += k.textContent;
     k = k.nextSibling;
   }
   var shader;
   if ( shaderScript.type == "x-shader/x-fragment" )
           shader = gl.createShader ( gl.FRAGMENT_SHADER );
   else if ( shaderScript.type == "x-shader/x-vertex" )
           shader = gl.createShader(gl.VERTEX_SHADER);
   else return null;
   gl.shaderSource(shader, str);
   gl.compileShader(shader);
   if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
      alert(gl.getShaderInfoLog(shader));
   return shader;
}

var gl, line_prog, transl = -50, xOffs = yOffs = 0,  drag  = 0,  xRot = yRot = 0, lines = [];
var mvMatrix = new CanvasMatrix4(),
    prMatrix = new CanvasMatrix4(),
    rotMat = new CanvasMatrix4();
var mvMatLoc = [], mvMatLine, lineLoc;
var M=60, N=3, K=12;

function webGLStart() {
   var canvas1 = document.getElementById("canvas1");
   try { gl = canvas1.getContext("experimental-webgl");
   } catch(e) {}

   line_prog  = gl.createProgram();
   gl.attachShader(line_prog, getShader( gl, "line-vs" ));
   gl.attachShader(line_prog, getShader( gl, "line-fs" ));
   lineLoc = 0;
   gl.bindAttribLocation(line_prog, lineLoc, "aPos");
   gl.linkProgram(line_prog);

   rotMat.makeIdentity();
   prMatrix.perspective(3, 1, 1, 1000);

   mvMatLine = gl.getUniformLocation(line_prog,"mvMatrix");
   gl.useProgram(line_prog);
   gl.uniformMatrix4fv( gl.getUniformLocation(line_prog,"prMatrix"), false, new Float32Array(prMatrix.getAsArray()) );
   init();

   canvas1.onmousedown = function ( ev ){
      drag  = 1;
      xOffs = ev.clientX;  yOffs = ev.clientY;
   }
   canvas1.onmouseup = function ( ev ){
      drag  = 0;
      xOffs = ev.clientX;  yOffs = ev.clientY;
   }
   canvas1.onmousemove = function ( ev ){
      if ( drag == 0 ) return;
      if ( ev.shiftKey ) {
         transl *= 1 + (ev.clientY - yOffs)/100;
      } else {
         yRot = - xOffs + ev.clientX;  
 	xRot = - yOffs + ev.clientY; 
      }
      xOffs = ev.clientX;  yOffs = ev.clientY;
   }

}

function init(){
   transl = -50; 
   xRot = 0; yRot = 0;
   xOffs = 0; yOffs = 0;  
   drag  = 0;  
   var as = [];
   var ac = [];
   var bs = [];
   var bc = [];
   for (var i=0; i<N; i++){
      as[i] = new Array(K);
      ac[i] = new Array(K);
      bs[i] = new Array(K);
      bc[i] = new Array(K);
   }
   as[0][ 1]= 1.097640051076110; bc[0][ 1]=-0.108957450183278;
   as[0][ 3]= 0.028090182332076; bc[0][ 3]= 0.032506096677853;
   as[0][ 5]= 0.007235718283341; bc[0][ 5]= 0.003762748006231;
   as[0][ 7]= 0.001210181377945; bc[0][ 7]= 0.001308690517932;
   as[0][ 9]= 0.000397710135507; bc[0][ 9]= 0.000289369558798;
   as[0][11]= 0.000096328571545; bc[0][11]= 0.000101643863860;

   as[1][ 1]=-0.108957450183278; bc[1][ 1]= 1.097640051076109;
   as[1][ 3]=-0.032506096677853; bc[1][ 3]=-0.028090182332075;
   as[1][ 5]= 0.003762748006231; bc[1][ 5]= 0.007235718283341;
   as[1][ 7]=-0.001308690517932; bc[1][ 7]=-0.001210181377945;
   as[1][ 9]= 0.000289369558798; bc[1][ 9]= 0.000397710135507;
   as[1][11]=-0.000101643863860; bc[1][11]=-0.000096328571545;

   as[2][ 1]=-0.988682600892831; bc[2][ 1]=-0.988682600892830;
   as[2][ 3]= 0.004415914345778; bc[2][ 3]=-0.004415914345778;
   as[2][ 5]=-0.010998466289572; bc[2][ 5]=-0.010998466289572;
   as[2][ 7]= 0.000098509139987; bc[2][ 7]=-0.000098509139987;
   as[2][ 9]=-0.000687079694304; bc[2][ 9]=-0.000687079694304;
   as[2][11]= 0.000005315292314; bc[2][11]=-0.000005315292314;

   var pathx = [];
   var pathy = [];
   var pathz = [];
   for (var i=0; i<N; i++){
      pathx[i] = new Array(M);
      pathy[i] = new Array(M);
      pathz[i] = new Array(M);
   }
   for (var i=0; i<N; i++) {
     for (var j=0; j<M; j++) {
       pathx[i][j] = 0.0;
       pathy[i][j] = 0.0;
       pathz[i][j] = 0.0;
       for (var k=1; k<K; k+=2) {
         pathx[i][j] += as[i][k]*Math.sin(k*j*2*Math.PI/M);
         pathy[i][j] += bc[i][k]*Math.cos(k*j*2*Math.PI/M);
       }
     }
   }

   lines = [];

   for (var i = 0; i < N; i++ ){
     lines.push( pathx[i][0], pathy[i][0], pathz[i][0] );  
     lines.push( pathx[i][0], pathy[i][0], pathz[i][0] );  
     for (var j=0; j<M; j++) {
       lines.push( pathx[i][j], pathy[i][j], pathz[i][j] );
     }
     lines.push( pathx[i][0], pathy[i][0], pathz[i][0] );  
     lines.push( pathx[i][0], pathy[i][0], pathz[i][0] );  
   }

   gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
   gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( lines ),gl.STATIC_DRAW);
   gl.vertexAttribPointer(lineLoc, 3, gl.FLOAT, false, 0, 0);

   gl.enableVertexAttribArray( lineLoc );

   gl.clearColor(0, 0, 0, 1);
   timer = setInterval(draw3d, 1./60.*1000.);
}

function draw3d(){
   gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
   rotMat.rotate(xRot, 1,0,0);  rotMat.rotate(yRot, 0,1,0);
   yRot = 0;  xRot = 0;
   gl.useProgram(line_prog);
   mvMatrix.load( rotMat );
   mvMatrix.translate(0, 0, transl);
   gl.uniformMatrix4fv( mvMatLine, false, new Float32Array(mvMatrix.getAsArray()) );
   gl.drawArrays(gl.LINE_STRIP, 0, lines.length/3);
}
</script> 
</head>

<body onload="webGLStart();"> 

<canvas id="canvas1" width="500" height="500"></canvas> 

</body></html>


